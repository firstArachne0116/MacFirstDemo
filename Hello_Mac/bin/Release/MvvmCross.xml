<?xml version="1.0"?>
<doc>
    <assembly>
        <name>MvvmCross</name>
    </assembly>
    <members>
        <member name="T:MvvmCross.Annotations.CanBeNullAttribute">
            <summary>
            Indicates that the value of the marked element could be <c>null</c> sometimes,
            so the check for <c>null</c> is necessary before its usage.
            </summary>
            <example><code>
            [CanBeNull] object Test() => null;
            
            void UseTest() {
              var p = Test();
              var s = p.ToString(); // Warning: Possible 'System.NullReferenceException'
            }
            </code></example>
        </member>
        <member name="T:MvvmCross.Annotations.NotNullAttribute">
            <summary>
            Indicates that the value of the marked element could never be <c>null</c>.
            </summary>
            <example><code>
            [NotNull] object Foo() {
              return null; // Warning: Possible 'null' assignment
            }
            </code></example>
        </member>
        <member name="T:MvvmCross.Annotations.ItemNotNullAttribute">
            <summary>
            Can be appplied to symbols of types derived from IEnumerable as well as to symbols of Task
            and Lazy classes to indicate that the value of a collection item, of the Task.Result property
            or of the Lazy.Value property can never be null.
            </summary>
        </member>
        <member name="T:MvvmCross.Annotations.ItemCanBeNullAttribute">
            <summary>
            Can be appplied to symbols of types derived from IEnumerable as well as to symbols of Task
            and Lazy classes to indicate that the value of a collection item, of the Task.Result property
            or of the Lazy.Value property can be null.
            </summary>
        </member>
        <member name="T:MvvmCross.Annotations.StringFormatMethodAttribute">
            <summary>
            Indicates that the marked method builds string by format pattern and (optional) arguments.
            Parameter, which contains format string, should be given in constructor. The format string
            should be in <see cref="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])"/>-like form.
            </summary>
            <example><code>
            [StringFormatMethod("message")]
            void ShowError(string message, params object[] args) { /* do something */ }
            
            void Foo() {
              ShowError("Failed: {0}"); // Warning: Non-existing argument in format string
            }
            </code></example>
        </member>
        <member name="M:MvvmCross.Annotations.StringFormatMethodAttribute.#ctor(System.String)">
            <param name="formatParameterName">
            Specifies which parameter of an annotated method should be treated as format-string
            </param>
        </member>
        <member name="T:MvvmCross.Annotations.ValueProviderAttribute">
            <summary>
            For a parameter that is expected to be one of the limited set of values.
            Specify fields of which type should be used as values for this parameter.
            </summary>
        </member>
        <member name="T:MvvmCross.Annotations.InvokerParameterNameAttribute">
            <summary>
            Indicates that the function argument should be string literal and match one
            of the parameters of the caller function. For example, ReSharper annotates
            the parameter of <see cref="T:System.ArgumentNullException"/>.
            </summary>
            <example><code>
            void Foo(string param) {
              if (param == null)
                throw new ArgumentNullException("par"); // Warning: Cannot resolve symbol
            }
            </code></example>
        </member>
        <member name="T:MvvmCross.Annotations.NotifyPropertyChangedInvocatorAttribute">
             <summary>
             Indicates that the method is contained in a type that implements
             <c>System.ComponentModel.INotifyPropertyChanged</c> interface and this method
             is used to notify that some property value changed.
             </summary>
             <remarks>
             The method should be non-static and conform to one of the supported signatures:
             <list>
             <item><c>NotifyChanged(string)</c></item>
             <item><c>NotifyChanged(params string[])</c></item>
             <item><c>NotifyChanged{T}(Expression{Func{T}})</c></item>
             <item><c>NotifyChanged{T,U}(Expression{Func{T,U}})</c></item>
             <item><c>SetProperty{T}(ref T, T, string)</c></item>
             </list>
             </remarks>
             <example><code>
             public class Foo : INotifyPropertyChanged {
               public event PropertyChangedEventHandler PropertyChanged;
             
               [NotifyPropertyChangedInvocator]
               protected virtual void NotifyChanged(string propertyName) { ... }
            
               string _name;
             
               public string Name {
                 get { return _name; }
                 set { _name = value; NotifyChanged("LastName"); /* Warning */ }
               }
             }
             </code>
             Examples of generated notifications:
             <list>
             <item><c>NotifyChanged("Property")</c></item>
             <item><c>NotifyChanged(() =&gt; Property)</c></item>
             <item><c>NotifyChanged((VM x) =&gt; x.Property)</c></item>
             <item><c>SetProperty(ref myField, value, "Property")</c></item>
             </list>
             </example>
        </member>
        <member name="T:MvvmCross.Annotations.ContractAnnotationAttribute">
            <summary>
            Describes dependency between method input and output.
            </summary>
            <syntax>
            <p>Function Definition Table syntax:</p>
            <list>
            <item>FDT      ::= FDTRow [;FDTRow]*</item>
            <item>FDTRow   ::= Input =&gt; Output | Output &lt;= Input</item>
            <item>Input    ::= ParameterName: Value [, Input]*</item>
            <item>Output   ::= [ParameterName: Value]* {halt|stop|void|nothing|Value}</item>
            <item>Value    ::= true | false | null | notnull | canbenull</item>
            </list>
            If method has single input parameter, it's name could be omitted.<br/>
            Using <c>halt</c> (or <c>void</c>/<c>nothing</c>, which is the same) for method output
            means that the methos doesn't return normally (throws or terminates the process).<br/>
            Value <c>canbenull</c> is only applicable for output parameters.<br/>
            You can use multiple <c>[ContractAnnotation]</c> for each FDT row, or use single attribute
            with rows separated by semicolon. There is no notion of order rows, all rows are checked
            for applicability and applied per each program state tracked by R# analysis.<br/>
            </syntax>
            <examples><list>
            <item><code>
            [ContractAnnotation("=&gt; halt")]
            public void TerminationMethod()
            </code></item>
            <item><code>
            [ContractAnnotation("halt &lt;= condition: false")]
            public void Assert(bool condition, string text) // regular assertion method
            </code></item>
            <item><code>
            [ContractAnnotation("s:null =&gt; true")]
            public bool IsNullOrEmpty(string s) // string.IsNullOrEmpty()
            </code></item>
            <item><code>
            // A method that returns null if the parameter is null,
            // and not null if the parameter is not null
            [ContractAnnotation("null =&gt; null; notnull =&gt; notnull")]
            public object Transform(object data) 
            </code></item>
            <item><code>
            [ContractAnnotation("=&gt; true, result: notnull; =&gt; false, result: null")]
            public bool TryParse(string s, out Person result)
            </code></item>
            </list></examples>
        </member>
        <member name="T:MvvmCross.Annotations.LocalizationRequiredAttribute">
            <summary>
            Indicates that marked element should be localized or not.
            </summary>
            <example><code>
            [LocalizationRequiredAttribute(true)]
            class Foo {
              string str = "my string"; // Warning: Localizable string
            }
            </code></example>
        </member>
        <member name="T:MvvmCross.Annotations.CannotApplyEqualityOperatorAttribute">
            <summary>
            Indicates that the value of the marked type (or its derivatives)
            cannot be compared using '==' or '!=' operators and <c>Equals()</c>
            should be used instead. However, using '==' or '!=' for comparison
            with <c>null</c> is always permitted.
            </summary>
            <example><code>
            [CannotApplyEqualityOperator]
            class NoEquality { }
            
            class UsesNoEquality {
              void Test() {
                var ca1 = new NoEquality();
                var ca2 = new NoEquality();
                if (ca1 != null) { // OK
                  bool condition = ca1 == ca2; // Warning
                }
              }
            }
            </code></example>
        </member>
        <member name="T:MvvmCross.Annotations.BaseTypeRequiredAttribute">
            <summary>
            When applied to a target attribute, specifies a requirement for any type marked
            with the target attribute to implement or inherit specific type or types.
            </summary>
            <example><code>
            [BaseTypeRequired(typeof(IComponent)] // Specify requirement
            class ComponentAttribute : Attribute { }
            
            [Component] // ComponentAttribute requires implementing IComponent interface
            class MyComponent : IComponent { }
            </code></example>
        </member>
        <member name="T:MvvmCross.Annotations.UsedImplicitlyAttribute">
            <summary>
            Indicates that the marked symbol is used implicitly (e.g. via reflection, in external library),
            so this symbol will not be marked as unused (as well as by other usage inspections).
            </summary>
        </member>
        <member name="T:MvvmCross.Annotations.MeansImplicitUseAttribute">
            <summary>
            Should be used on attributes and causes ReSharper to not mark symbols marked with such attributes
            as unused (as well as by other usage inspections)
            </summary>
        </member>
        <member name="F:MvvmCross.Annotations.ImplicitUseKindFlags.Access">
            <summary>Only entity marked with attribute considered used.</summary>
        </member>
        <member name="F:MvvmCross.Annotations.ImplicitUseKindFlags.Assign">
            <summary>Indicates implicit assignment to a member.</summary>
        </member>
        <member name="F:MvvmCross.Annotations.ImplicitUseKindFlags.InstantiatedWithFixedConstructorSignature">
            <summary>
            Indicates implicit instantiation of a type with fixed constructor signature.
            That means any unused constructor parameters won't be reported as such.
            </summary>
        </member>
        <member name="F:MvvmCross.Annotations.ImplicitUseKindFlags.InstantiatedNoFixedConstructorSignature">
            <summary>Indicates implicit instantiation of a type.</summary>
        </member>
        <member name="T:MvvmCross.Annotations.ImplicitUseTargetFlags">
            <summary>
            Specify what is considered used implicitly when marked
            with <see cref="T:MvvmCross.Annotations.MeansImplicitUseAttribute"/> or <see cref="T:MvvmCross.Annotations.UsedImplicitlyAttribute"/>.
            </summary>
        </member>
        <member name="F:MvvmCross.Annotations.ImplicitUseTargetFlags.Members">
            <summary>Members of entity marked with attribute are considered used.</summary>
        </member>
        <member name="F:MvvmCross.Annotations.ImplicitUseTargetFlags.WithMembers">
            <summary>Entity marked with attribute and all its members considered used.</summary>
        </member>
        <member name="T:MvvmCross.Annotations.PublicAPIAttribute">
            <summary>
            This attribute is intended to mark publicly available API
            which should not be removed and so is treated as used.
            </summary>
        </member>
        <member name="T:MvvmCross.Annotations.InstantHandleAttribute">
            <summary>
            Tells code analysis engine if the parameter is completely handled when the invoked method is on stack.
            If the parameter is a delegate, indicates that delegate is executed while the method is executed.
            If the parameter is an enumerable, indicates that it is enumerated while the method is executed.
            </summary>
        </member>
        <member name="T:MvvmCross.Annotations.PureAttribute">
            <summary>
            Indicates that a method does not make any observable state changes.
            The same as <c>System.Diagnostics.Contracts.PureAttribute</c>.
            </summary>
            <example><code>
            [Pure] int Multiply(int x, int y) => x * y;
            
            void M() {
              Multiply(123, 42); // Waring: Return value of pure method is not used
            }
            </code></example>
        </member>
        <member name="T:MvvmCross.Annotations.MustUseReturnValueAttribute">
            <summary>
            Indicates that the return value of method invocation must be used.
            </summary>
        </member>
        <member name="T:MvvmCross.Annotations.ProvidesContextAttribute">
            <summary>
            Indicates the type member or parameter of some type, that should be used instead of all other ways
            to get the value that type. This annotation is useful when you have some "context" value evaluated
            and stored somewhere, meaning that all other ways to get this value must be consolidated with existing one.
            </summary>
            <example><code>
            class Foo {
              [ProvidesContext] IBarService _barService = ...;
            
              void ProcessNode(INode node) {
                DoSomething(node, node.GetGlobalServices().Bar);
                //              ^ Warning: use value of '_barService' field
              }
            }
            </code></example>
        </member>
        <member name="T:MvvmCross.Annotations.PathReferenceAttribute">
            <summary>
            Indicates that a parameter is a path to a file or a folder within a web project.
            Path can be relative or absolute, starting from web root (~).
            </summary>
        </member>
        <member name="T:MvvmCross.Annotations.SourceTemplateAttribute">
            <summary>
            An extension method marked with this attribute is processed by ReSharper code completion
            as a 'Source Template'. When extension method is completed over some expression, it's source code
            is automatically expanded like a template at call site.
            </summary>
            <remarks>
            Template method body can contain valid source code and/or special comments starting with '$'.
            Text inside these comments is added as source code when the template is applied. Template parameters
            can be used either as additional method parameters or as identifiers wrapped in two '$' signs.
            Use the <see cref="T:MvvmCross.Annotations.MacroAttribute"/> attribute to specify macros for parameters.
            </remarks>
            <example>
            In this example, the 'forEach' method is a source template available over all values
            of enumerable types, producing ordinary C# 'foreach' statement and placing caret inside block:
            <code>
            [SourceTemplate]
            public static void forEach&lt;T&gt;(this IEnumerable&lt;T&gt; xs) {
              foreach (var x in xs) {
                 //$ $END$
              }
            }
            </code>
            </example>
        </member>
        <member name="T:MvvmCross.Annotations.MacroAttribute">
            <summary>
            Allows specifying a macro for a parameter of a <see cref="T:MvvmCross.Annotations.SourceTemplateAttribute">source template</see>.
            </summary>
            <remarks>
            You can apply the attribute on the whole method or on any of its additional parameters. The macro expression
            is defined in the <see cref="P:MvvmCross.Annotations.MacroAttribute.Expression"/> property. When applied on a method, the target
            template parameter is defined in the <see cref="P:MvvmCross.Annotations.MacroAttribute.Target"/> property. To apply the macro silently
            for the parameter, set the <see cref="P:MvvmCross.Annotations.MacroAttribute.Editable"/> property value = -1.
            </remarks>
            <example>
            Applying the attribute on a source template method:
            <code>
            [SourceTemplate, Macro(Target = "item", Expression = "suggestVariableName()")]
            public static void forEach&lt;T&gt;(this IEnumerable&lt;T&gt; collection) {
              foreach (var item in collection) {
                //$ $END$
              }
            }
            </code>
            Applying the attribute on a template method parameter:
            <code>
            [SourceTemplate]
            public static void something(this Entity x, [Macro(Expression = "guid()", Editable = -1)] string newguid) {
              /*$ var $x$Id = "$newguid$" + x.ToString();
              x.DoSomething($x$Id); */
            }
            </code>
            </example>
        </member>
        <member name="P:MvvmCross.Annotations.MacroAttribute.Expression">
            <summary>
            Allows specifying a macro that will be executed for a <see cref="T:MvvmCross.Annotations.SourceTemplateAttribute">source template</see>
            parameter when the template is expanded.
            </summary>
        </member>
        <member name="P:MvvmCross.Annotations.MacroAttribute.Editable">
            <summary>
            Allows specifying which occurrence of the target parameter becomes editable when the template is deployed.
            </summary>
            <remarks>
            If the target parameter is used several times in the template, only one occurrence becomes editable;
            other occurrences are changed synchronously. To specify the zero-based index of the editable occurrence,
            use values >= 0. To make the parameter non-editable when the template is expanded, use -1.
            </remarks>>
        </member>
        <member name="P:MvvmCross.Annotations.MacroAttribute.Target">
            <summary>
            Identifies the target parameter of a <see cref="T:MvvmCross.Annotations.SourceTemplateAttribute">source template</see> if the
            <see cref="T:MvvmCross.Annotations.MacroAttribute"/> is applied on a template method.
            </summary>
        </member>
        <member name="T:MvvmCross.Annotations.AspMvcActionAttribute">
            <summary>
            ASP.NET MVC attribute. If applied to a parameter, indicates that the parameter
            is an MVC action. If applied to a method, the MVC action name is calculated
            implicitly from the context. Use this attribute for custom wrappers similar to
            <c>System.Web.Mvc.Html.ChildActionExtensions.RenderAction(HtmlHelper, String)</c>.
            </summary>
        </member>
        <member name="T:MvvmCross.Annotations.AspMvcAreaAttribute">
            <summary>
            ASP.NET MVC attribute. Indicates that a parameter is an MVC area.
            Use this attribute for custom wrappers similar to
            <c>System.Web.Mvc.Html.ChildActionExtensions.RenderAction(HtmlHelper, String)</c>.
            </summary>
        </member>
        <member name="T:MvvmCross.Annotations.AspMvcControllerAttribute">
            <summary>
            ASP.NET MVC attribute. If applied to a parameter, indicates that the parameter is
            an MVC controller. If applied to a method, the MVC controller name is calculated
            implicitly from the context. Use this attribute for custom wrappers similar to
            <c>System.Web.Mvc.Html.ChildActionExtensions.RenderAction(HtmlHelper, String, String)</c>.
            </summary>
        </member>
        <member name="T:MvvmCross.Annotations.AspMvcMasterAttribute">
            <summary>
            ASP.NET MVC attribute. Indicates that a parameter is an MVC Master. Use this attribute
            for custom wrappers similar to <c>System.Web.Mvc.Controller.View(String, String)</c>.
            </summary>
        </member>
        <member name="T:MvvmCross.Annotations.AspMvcModelTypeAttribute">
            <summary>
            ASP.NET MVC attribute. Indicates that a parameter is an MVC model type. Use this attribute
            for custom wrappers similar to <c>System.Web.Mvc.Controller.View(String, Object)</c>.
            </summary>
        </member>
        <member name="T:MvvmCross.Annotations.AspMvcPartialViewAttribute">
            <summary>
            ASP.NET MVC attribute. If applied to a parameter, indicates that the parameter is an MVC
            partial view. If applied to a method, the MVC partial view name is calculated implicitly
            from the context. Use this attribute for custom wrappers similar to
            <c>System.Web.Mvc.Html.RenderPartialExtensions.RenderPartial(HtmlHelper, String)</c>.
            </summary>
        </member>
        <member name="T:MvvmCross.Annotations.AspMvcSuppressViewErrorAttribute">
            <summary>
            ASP.NET MVC attribute. Allows disabling inspections for MVC views within a class or a method.
            </summary>
        </member>
        <member name="T:MvvmCross.Annotations.AspMvcDisplayTemplateAttribute">
            <summary>
            ASP.NET MVC attribute. Indicates that a parameter is an MVC display template.
            Use this attribute for custom wrappers similar to 
            <c>System.Web.Mvc.Html.DisplayExtensions.DisplayForModel(HtmlHelper, String)</c>.
            </summary>
        </member>
        <member name="T:MvvmCross.Annotations.AspMvcEditorTemplateAttribute">
            <summary>
            ASP.NET MVC attribute. Indicates that a parameter is an MVC editor template.
            Use this attribute for custom wrappers similar to
            <c>System.Web.Mvc.Html.EditorExtensions.EditorForModel(HtmlHelper, String)</c>.
            </summary>
        </member>
        <member name="T:MvvmCross.Annotations.AspMvcTemplateAttribute">
            <summary>
            ASP.NET MVC attribute. Indicates that a parameter is an MVC template.
            Use this attribute for custom wrappers similar to
            <c>System.ComponentModel.DataAnnotations.UIHintAttribute(System.String)</c>.
            </summary>
        </member>
        <member name="T:MvvmCross.Annotations.AspMvcViewAttribute">
            <summary>
            ASP.NET MVC attribute. If applied to a parameter, indicates that the parameter
            is an MVC view component. If applied to a method, the MVC view name is calculated implicitly
            from the context. Use this attribute for custom wrappers similar to
            <c>System.Web.Mvc.Controller.View(Object)</c>.
            </summary>
        </member>
        <member name="T:MvvmCross.Annotations.AspMvcViewComponentAttribute">
            <summary>
            ASP.NET MVC attribute. If applied to a parameter, indicates that the parameter
            is an MVC view component name.
            </summary>
        </member>
        <member name="T:MvvmCross.Annotations.AspMvcViewComponentViewAttribute">
            <summary>
            ASP.NET MVC attribute. If applied to a parameter, indicates that the parameter
            is an MVC view component view. If applied to a method, the MVC view component view name is default.
            </summary>
        </member>
        <member name="T:MvvmCross.Annotations.AspMvcActionSelectorAttribute">
            <summary>
            ASP.NET MVC attribute. When applied to a parameter of an attribute,
            indicates that this parameter is an MVC action name.
            </summary>
            <example><code>
            [ActionName("Foo")]
            public ActionResult Login(string returnUrl) {
              ViewBag.ReturnUrl = Url.Action("Foo"); // OK
              return RedirectToAction("Bar"); // Error: Cannot resolve action
            }
            </code></example>
        </member>
        <member name="T:MvvmCross.Annotations.RazorSectionAttribute">
            <summary>
            Razor attribute. Indicates that a parameter or a method is a Razor section.
            Use this attribute for custom wrappers similar to 
            <c>System.Web.WebPages.WebPageBase.RenderSection(String)</c>.
            </summary>
        </member>
        <member name="T:MvvmCross.Annotations.CollectionAccessAttribute">
            <summary>
            Indicates how method, constructor invocation or property access
            over collection type affects content of the collection.
            </summary>
        </member>
        <member name="F:MvvmCross.Annotations.CollectionAccessType.None">
            <summary>Method does not use or modify content of the collection.</summary>
        </member>
        <member name="F:MvvmCross.Annotations.CollectionAccessType.Read">
            <summary>Method only reads content of the collection but does not modify it.</summary>
        </member>
        <member name="F:MvvmCross.Annotations.CollectionAccessType.ModifyExistingContent">
            <summary>Method can change content of the collection but does not add new elements.</summary>
        </member>
        <member name="F:MvvmCross.Annotations.CollectionAccessType.UpdatedContent">
            <summary>Method can add new elements to the collection.</summary>
        </member>
        <member name="T:MvvmCross.Annotations.AssertionMethodAttribute">
            <summary>
            Indicates that the marked method is assertion method, i.e. it halts control flow if
            one of the conditions is satisfied. To set the condition, mark one of the parameters with 
            <see cref="T:MvvmCross.Annotations.AssertionConditionAttribute"/> attribute.
            </summary>
        </member>
        <member name="T:MvvmCross.Annotations.AssertionConditionAttribute">
            <summary>
            Indicates the condition parameter of the assertion method. The method itself should be
            marked by <see cref="T:MvvmCross.Annotations.AssertionMethodAttribute"/> attribute. The mandatory argument of
            the attribute is the assertion type.
            </summary>
        </member>
        <member name="T:MvvmCross.Annotations.AssertionConditionType">
            <summary>
            Specifies assertion type. If the assertion method argument satisfies the condition,
            then the execution continues. Otherwise, execution is assumed to be halted.
            </summary>
        </member>
        <member name="F:MvvmCross.Annotations.AssertionConditionType.IS_TRUE">
            <summary>Marked parameter should be evaluated to true.</summary>
        </member>
        <member name="F:MvvmCross.Annotations.AssertionConditionType.IS_FALSE">
            <summary>Marked parameter should be evaluated to false.</summary>
        </member>
        <member name="F:MvvmCross.Annotations.AssertionConditionType.IS_NULL">
            <summary>Marked parameter should be evaluated to null value.</summary>
        </member>
        <member name="F:MvvmCross.Annotations.AssertionConditionType.IS_NOT_NULL">
            <summary>Marked parameter should be evaluated to not null value.</summary>
        </member>
        <member name="T:MvvmCross.Annotations.TerminatesProgramAttribute">
            <summary>
            Indicates that the marked method unconditionally terminates control flow execution.
            For example, it could unconditionally throw exception.
            </summary>
        </member>
        <member name="T:MvvmCross.Annotations.LinqTunnelAttribute">
            <summary>
            Indicates that method is pure LINQ method, with postponed enumeration (like Enumerable.Select,
            .Where). This annotation allows inference of [InstantHandle] annotation for parameters
            of delegate type by analyzing LINQ method chains.
            </summary>
        </member>
        <member name="T:MvvmCross.Annotations.NoEnumerationAttribute">
            <summary>
            Indicates that IEnumerable, passed as parameter, is not enumerated.
            </summary>
        </member>
        <member name="T:MvvmCross.Annotations.RegexPatternAttribute">
            <summary>
            Indicates that parameter is regular expression pattern.
            </summary>
        </member>
        <member name="T:MvvmCross.Annotations.NoReorderAttribute">
            <summary>
            Prevents the Member Reordering feature from tossing members of the marked class.
            </summary>
            <remarks>
            The attribute must be mentioned in your member reordering patterns
            </remarks>
        </member>
        <member name="T:MvvmCross.Annotations.XamlItemsControlAttribute">
            <summary>
            XAML attribute. Indicates the type that has <c>ItemsSource</c> property and should be treated
            as <c>ItemsControl</c>-derived type, to enable inner items <c>DataContext</c> type resolve.
            </summary>
        </member>
        <member name="T:MvvmCross.Annotations.XamlItemBindingOfItemsControlAttribute">
            <summary>
            XAML attribute. Indicates the property of some <c>BindingBase</c>-derived type, that
            is used to bind some item of <c>ItemsControl</c>-derived type. This annotation will
            enable the <c>DataContext</c> type resolve for XAML bindings for such properties.
            </summary>
            <remarks>
            Property should have the tree ancestor of the <c>ItemsControl</c> type or
            marked with the <see cref="T:MvvmCross.Annotations.XamlItemsControlAttribute"/> attribute.
            </remarks>
        </member>
        <member name="T:MvvmCross.Binding.BindingContext.MvxTaskBasedBindingContext">
            <summary>
            OnDataContextChange executes asynchronously on a worker thread
            </summary>
        </member>
        <member name="M:MvvmCross.Binding.BindingContext.MvxTaskBasedBindingContext.OnDataContextChange">
            <summary>
            Must be called on main thread as it creates the target bindings, and creating target bindings might subscribe to events that
            needs to be done on main thread (like touchupinside). 
            If the code is run in Synchronous mode there will be a performance hit, there are however some use-cases(iOS automatic resizing cells).
            </summary>
        </member>
        <member name="T:MvvmCross.Binding.Bindings.Source.Construction.MvxPropertySourceBindingFactoryExtension">
            <summary>
            Uses a global cache of calls in Reflection namespace
            </summary>
        </member>
        <member name="T:MvvmCross.Binding.Parse.PropertyPath.MvxSourcePropertyPathParser">
            <summary>
            Stateless parser with global caching of tokens
            </summary>
        </member>
        <member name="T:MvvmCross.Core.MvxSetupSingleton">
            <summary>
            The setup singleton is designed to ensure only a single instance
            of MvxSetup is created and invoked. There are three important methods
            to the MvxSetupSingleton class:
            EnsureSingletonAvailable - this is a static method that will return 
            the one and only instance of MvxSetupSingleton. This method is protected
            as it's assumed that each platform will provide a platform specific
            public overload for this method which will include any platform parameters
            required
            EnsureInitialized - this is an instance method that should be called 
            to guarrantee that setup has been created and initialized. This method 
            is blocking so make sure it's only called at a point where there
            are no other UI methods are being invoked. This method is typically called
            in applications where there is no splash screen.
            InitializeAndMonitor - this is an instance method that can be called 
            to make sure that the initialization of setup has begun. It registers
            an object to be notified when setup initialization has completed. The callback
            will be raised on the UI thread. This method is not blocking, and doesn't
            guarrantee setup initialize has finished when it returns. This method is 
            typically called by the splash screen view of an application, passing
            itself in as the object to be notified. On notification the splash screen 
            view will trigger navigation to the first view
            </summary>
        </member>
        <member name="M:MvvmCross.Core.MvxSetupSingleton.PlatformSetup``1">
            <summary>
            Returns a platform specific instance of Setup
            A useful overload to allow for platform specific
            setup logic to be invoked.
            </summary>
            <typeparam name="TMvxSetup">The platform specific setup type</typeparam>
            <returns>A platform specific instance of Setup</returns>
        </member>
        <member name="M:MvvmCross.Core.MvxSetupSingleton.EnsureSingletonAvailable``1">
            <summary>
            Returns a singleton object that is used to manage the creation and
            execution of setup
            </summary>
            <typeparam name="TMvxSetupSingleton">The platform specific setup singleton type</typeparam>
            <returns>A platform specific setup singleton</returns>
        </member>
        <member name="M:MvvmCross.IoC.MvxConventionAttributeExtensions.IsConventional(System.Type)">
            <summary>
            A type is conventional if and only it is:
            - not marked with an unconventional attribute
            - all marked conditional conventions return true
            </summary>
            <param name="candidateType"></param>
            <returns></returns>
        </member>
        <member name="M:MvvmCross.IoC.MvxConventionAttributeExtensions.IsConventional(System.Reflection.PropertyInfo)">
            <summary>
            A propertyInfo is conventional if and only it is:
            - not marked with an unconventional attribute
            - all marked conditional conventions return true
            </summary>
            <param name="propertyInfo"></param>
            <returns></returns>
        </member>
        <member name="T:MvvmCross.IoC.MvxIoCProvider">
             <summary>
             Singleton IoC Provider.
            
             Delegates to the <see cref="T:MvvmCross.IoC.MvxIoCContainer"/> implementation
             </summary>
        </member>
        <member name="M:MvvmCross.Logging.LogProviders.LogMessageFormatter.SimulateStructuredLogging(System.Func{System.String},System.Object[])">
            <summary>
            Some logging frameworks support structured logging, such as serilog. This will allow you to add names to structured data in a format string:
            For example: Log("Log message to {user}", user). This only works with serilog, but as the user of LibLog, you don't know if serilog is actually 
            used. So, this class simulates that. it will replace any text in {curly braces} with an index number. 
            
            "Log {message} to {user}" would turn into => "Log {0} to {1}". Then the format parameters are handled using regular .net string.Format.
            </summary>
            <param name="messageBuilder">The message builder.</param>
            <param name="formatParameters">The format parameters.</param>
            <returns></returns>
        </member>
        <member name="T:MvvmCross.Logging.LogProviders.LoupeLogProvider.WriteDelegate">
            <summary>
            The form of the Loupe Log.Write method we're using
            </summary>
        </member>
        <member name="T:MvvmCross.Logging.MvxLogLevel">
            <summary>
            The log level.
            </summary>
        </member>
        <member name="P:MvvmCross.Mvx.IoCProvider">
            <summary>
            Returns a singleton instance of the default IoC Provider. If possible use dependency injection instead.
            </summary>
        </member>
        <member name="M:MvvmCross.Navigation.IMvxNavigationCache.GetValueOrDefault``1(System.String,``0)">
            <summary>
            Gets the current value or the default that you specify.
            </summary>
            <typeparam name="T">Vaue of t (bool, int, float, long, string)</typeparam>
            <param name="key">Key for settings</param>
            <param name="defaultValue">default value if not set</param>
            <returns>Value or default</returns>
        </member>
        <member name="M:MvvmCross.Navigation.IMvxNavigationCache.AddValue``1(System.String,``0)">
            <summary>
            Adds or updates the value 
            </summary>
            <param name="key">Key</param>
            <param name="value">Value to set</param>
            <returns>True of was added or updated and you need to save it.</returns>
        </member>
        <member name="M:MvvmCross.Navigation.IMvxNavigationCache.Remove(System.String)">
            <summary>
            Removes a desired key
            </summary>
            <param name="key">Key</param>
        </member>
        <member name="M:MvvmCross.Navigation.IMvxNavigationCache.Clear">
            <summary>
            Clear all keys
            </summary>
        </member>
        <member name="M:MvvmCross.Navigation.IMvxNavigationCache.Contains(System.String)">
            <summary>
            Checks to see if the key has been added.
            </summary>
            <param name="key">Key to check</param>
            <returns>True if contains key, else false</returns>
        </member>
        <member name="T:MvvmCross.Navigation.IMvxNavigationService">
            <summary>
            Allows for Task and URI based navigation in MvvmCross
            </summary>
        </member>
        <member name="M:MvvmCross.Navigation.IMvxNavigationService.LoadRoutes(System.Collections.Generic.IEnumerable{System.Reflection.Assembly})">
            <summary>
            Loads all navigation routes based on the referenced assemblies
            </summary>
            <param name="assemblies">The assemblies that should be indexed for routes</param>
        </member>
        <member name="M:MvvmCross.Navigation.IMvxNavigationService.Navigate(MvvmCross.ViewModels.IMvxViewModel,MvvmCross.ViewModels.IMvxBundle,System.Threading.CancellationToken)">
            <summary>
            Navigates to an instance of a ViewModel
            </summary>
            <param name="viewModel"></param>
            <param name="presentationBundle"></param>
            <param name="cancellationToken"></param>
            <returns>Boolean indicating successful navigation</returns>
        </member>
        <member name="M:MvvmCross.Navigation.IMvxNavigationService.Navigate``1(MvvmCross.ViewModels.IMvxViewModel{``0},``0,MvvmCross.ViewModels.IMvxBundle,System.Threading.CancellationToken)">
            <summary>
            Navigates to an instance of a ViewModel and passes TParameter
            </summary>
            <typeparam name="TParameter"></typeparam>
            <param name="viewModel"></param>
            <param name="param"></param>
            <param name="presentationBundle"></param>
            <param name="cancellationToken"></param>
            <returns>Boolean indicating successful navigation</returns>
        </member>
        <member name="M:MvvmCross.Navigation.IMvxNavigationService.Navigate``1(MvvmCross.ViewModels.IMvxViewModelResult{``0},MvvmCross.ViewModels.IMvxBundle,System.Threading.CancellationToken)">
            <summary>
            Navigates to an instance of a ViewModel and returns TResult
            </summary>
            <typeparam name="TResult"></typeparam>
            <param name="viewModel"></param>
            <param name="presentationBundle"></param>
            <param name="cancellationToken"></param>
            <returns></returns>
        </member>
        <member name="M:MvvmCross.Navigation.IMvxNavigationService.Navigate``2(MvvmCross.ViewModels.IMvxViewModel{``0,``1},``0,MvvmCross.ViewModels.IMvxBundle,System.Threading.CancellationToken)">
            <summary>
            Navigates to an instance of a ViewModel passes TParameter and returns TResult
            </summary>
            <typeparam name="TParameter"></typeparam>
            <typeparam name="TResult"></typeparam>
            <param name="viewModel"></param>
            <param name="param"></param>
            <param name="presentationBundle"></param>
            <param name="cancellationToken"></param>
            <returns></returns>
        </member>
        <member name="M:MvvmCross.Navigation.IMvxNavigationService.Navigate(System.Type,MvvmCross.ViewModels.IMvxBundle,System.Threading.CancellationToken)">
            <summary>
            Navigates to a ViewModel Type
            </summary>
            <param name="viewModelType"></param>
            <param name="presentationBundle"></param>
            <param name="cancellationToken"></param>
            <returns>Boolean indicating successful navigation</returns>
        </member>
        <member name="M:MvvmCross.Navigation.IMvxNavigationService.Navigate``1(System.Type,``0,MvvmCross.ViewModels.IMvxBundle,System.Threading.CancellationToken)">
            <summary>
            Navigates to a ViewModel Type and passes TParameter
            </summary>
            <typeparam name="TParameter"></typeparam>
            <param name="viewModelType"></param>
            <param name="param"></param>
            <param name="presentationBundle"></param>
            <param name="cancellationToken"></param>
            <returns>Boolean indicating successful navigation</returns>
        </member>
        <member name="M:MvvmCross.Navigation.IMvxNavigationService.Navigate``1(System.Type,MvvmCross.ViewModels.IMvxBundle,System.Threading.CancellationToken)">
            <summary>
            Navigates to a ViewModel Type passes and returns TResult
            </summary>
            <typeparam name="TResult"></typeparam>
            <param name="viewModelType"></param>
            <param name="presentationBundle"></param>
            <param name="cancellationToken"></param>
            <returns></returns>
        </member>
        <member name="M:MvvmCross.Navigation.IMvxNavigationService.Navigate``2(System.Type,``0,MvvmCross.ViewModels.IMvxBundle,System.Threading.CancellationToken)">
            <summary>
            Navigates to a ViewModel Type passes TParameter and returns TResult
            </summary>
            <typeparam name="TParameter"></typeparam>
            <typeparam name="TResult"></typeparam>
            <param name="viewModelType"></param>
            <param name="param"></param>
            <param name="presentationBundle"></param>
            <param name="cancellationToken"></param>
            <returns></returns>
        </member>
        <member name="M:MvvmCross.Navigation.IMvxNavigationService.Navigate(System.String,MvvmCross.ViewModels.IMvxBundle,System.Threading.CancellationToken)">
            <summary>
            Translates the provided Uri to a ViewModel request and dispatches it.
            </summary>
            <param name="path">URI to route</param>
            <param name="presentationBundle"></param>
            <param name="cancellationToken"></param>
            <returns>Boolean indicating successful navigation</returns>
        </member>
        <member name="M:MvvmCross.Navigation.IMvxNavigationService.Navigate``1(System.String,``0,MvvmCross.ViewModels.IMvxBundle,System.Threading.CancellationToken)">
            <summary>
            Translates the provided Uri to a ViewModel request and dispatches it.
            </summary>
            <typeparam name="TParameter"></typeparam>
            <param name="path"></param>
            <param name="param"></param>
            <param name="presentationBundle"></param>
            <param name="cancellationToken"></param>
            <returns>Boolean indicating successful navigation</returns>
        </member>
        <member name="M:MvvmCross.Navigation.IMvxNavigationService.Navigate``1(System.String,MvvmCross.ViewModels.IMvxBundle,System.Threading.CancellationToken)">
            <summary>
            Translates the provided Uri to a ViewModel request and dispatches it.
            </summary>
            <typeparam name="TResult"></typeparam>
            <param name="path"></param>
            <param name="presentationBundle"></param>
            <param name="cancellationToken"></param>
            <returns></returns>
        </member>
        <member name="M:MvvmCross.Navigation.IMvxNavigationService.Navigate``2(System.String,``0,MvvmCross.ViewModels.IMvxBundle,System.Threading.CancellationToken)">
            <summary>
            Translates the provided Uri to a ViewModel request and dispatches it.
            </summary>
            <typeparam name="TParameter"></typeparam>
            <typeparam name="TResult"></typeparam>
            <param name="path"></param>
            <param name="param"></param>
            <param name="presentationBundle"></param>
            <param name="cancellationToken"></param>
            <returns></returns>
        </member>
        <member name="M:MvvmCross.Navigation.IMvxNavigationService.CanNavigate(System.String)">
            <summary>
            Verifies if the provided Uri can be routed to a ViewModel request.
            </summary>
            <param name="path">URI to route</param>
            <returns>True if the uri can be routed or false if it cannot.</returns>
        </member>
        <member name="M:MvvmCross.Navigation.IMvxNavigationService.CanNavigate``1">
            <summary>
            Verifies if the provided viewmodel is available
            </summary>
            <returns>True if the ViewModel is available</returns>
        </member>
        <member name="M:MvvmCross.Navigation.IMvxNavigationService.CanNavigate(System.Type)">
            <summary>
            Verifies if the provided viewmodel is available
            </summary>
            <param name="viewModelType">ViewModel type to check</param>
            <returns>True if the ViewModel is available</returns>
        </member>
        <member name="M:MvvmCross.Navigation.IMvxNavigationService.Close(MvvmCross.ViewModels.IMvxViewModel,System.Threading.CancellationToken)">
            <summary>
            Closes the View attached to the ViewModel
            </summary>
            <param name="viewModel"></param>
            <param name="cancellationToken"></param>
            <returns></returns>
        </member>
        <member name="M:MvvmCross.Navigation.IMvxNavigationService.Close``1(MvvmCross.ViewModels.IMvxViewModelResult{``0},``0,System.Threading.CancellationToken)">
            <summary>
            Closes the View attached to the ViewModel and returns a result to the underlaying ViewModel
            </summary>
            <typeparam name="TResult"></typeparam>
            <param name="viewModel"></param>
            <param name="result"></param>
            <param name="cancellationToken"></param>
            <returns></returns>
        </member>
        <member name="M:MvvmCross.Navigation.IMvxNavigationService.ChangePresentation(MvvmCross.ViewModels.MvxPresentationHint,System.Threading.CancellationToken)">
            <summary>
            Dispatches a ChangePresentation with Hint
            </summary>
            <param name="hint"></param>
            <param name="cancellationToken"></param>
            <returns></returns>
        </member>
        <member name="M:MvvmCross.Navigation.MvxNavigationExtensions.CanNavigate(MvvmCross.Navigation.IMvxNavigationService,System.Uri)">
            <summary>
            Verifies if the provided Uri can be routed to a ViewModel request.
            </summary>
            <param name="navigationService"></param>
            <param name="path">URI to route</param>
            <returns>True if the uri can be routed or false if it cannot.</returns>
        </member>
        <member name="M:MvvmCross.Navigation.MvxNavigationExtensions.Navigate(MvvmCross.Navigation.IMvxNavigationService,System.Uri,MvvmCross.ViewModels.IMvxBundle,System.Threading.CancellationToken)">
            <summary>
            Translates the provided Uri to a ViewModel request and dispatches it.
            </summary>
            <param name="navigationService"></param>
            <param name="path">URI to route</param>
            <param name="presentationBundle"></param>
            <param name="cancellationToken"></param>
            <returns>A task to await upon</returns>
        </member>
        <member name="P:MvvmCross.Presenters.Attributes.IMvxPresentationAttribute.ViewModelType">
            <summary>
            That shall be used only if you are using non generic views.
            </summary>
        </member>
        <member name="P:MvvmCross.Presenters.Attributes.IMvxPresentationAttribute.ViewType">
            <summary>
            Type of the view
            </summary>
        </member>
        <member name="P:MvvmCross.Presenters.Attributes.MvxBasePresentationAttribute.ViewModelType">
            <inheritdoc />
        </member>
        <member name="P:MvvmCross.Presenters.Attributes.MvxBasePresentationAttribute.ViewType">
            <inheritdoc />
        </member>
        <member name="M:MvvmCross.ViewModels.MvxApplication.Initialize">
            <summary>
            Any initialization steps that can be done in the background
            </summary>
        </member>
        <member name="M:MvvmCross.ViewModels.MvxApplication.Startup">
            <summary>
            Any initialization steps that need to be done on the UI thread
            </summary>
        </member>
        <member name="M:MvvmCross.ViewModels.MvxApplication.Reset">
            <summary>
            If the application is restarted (eg primary activity on Android 
            can be restarted) this method will be called before Startup
            is called again
            </summary>
        </member>
        <member name="T:MvvmCross.ViewModels.MvxNotifyTask">
            <summary>
            Watches a task and raises property-changed notifications when the task completes.
            </summary>
        </member>
        <member name="M:MvvmCross.ViewModels.MvxNotifyTask.#ctor(System.Threading.Tasks.Task,System.Action{System.Exception})">
            <summary>
            Initializes a task notifier watching the specified task.
            </summary>
            <param name="task">The task to watch.</param>
            <param name="onException">Callback to be run when an error happens</param>
        </member>
        <member name="P:MvvmCross.ViewModels.MvxNotifyTask.Task">
            <summary>
            Gets the task being watched. This property never changes and is never <c>null</c>.
            </summary>
        </member>
        <member name="P:MvvmCross.ViewModels.MvxNotifyTask.TaskCompleted">
            <summary>
            Gets a task that completes successfully when <see cref="P:MvvmCross.ViewModels.MvxNotifyTask.Task"/> completes (successfully, faulted, or canceled). This property never changes and is never <c>null</c>.
            </summary>
        </member>
        <member name="P:MvvmCross.ViewModels.MvxNotifyTask.Status">
            <summary>
            Gets the current task status. This property raises a notification when the task completes.
            </summary>
        </member>
        <member name="P:MvvmCross.ViewModels.MvxNotifyTask.IsCompleted">
            <summary>
            Gets whether the task has completed. This property raises a notification when the value changes to <c>true</c>.
            </summary>
        </member>
        <member name="P:MvvmCross.ViewModels.MvxNotifyTask.IsNotCompleted">
            <summary>
            Gets whether the task is busy (not completed). This property raises a notification when the value changes to <c>false</c>.
            </summary>
        </member>
        <member name="P:MvvmCross.ViewModels.MvxNotifyTask.IsSuccessfullyCompleted">
            <summary>
            Gets whether the task has completed successfully. This property raises a notification when the value changes to <c>true</c>.
            </summary>
        </member>
        <member name="P:MvvmCross.ViewModels.MvxNotifyTask.IsCanceled">
            <summary>
            Gets whether the task has been canceled. This property raises a notification only if the task is canceled (i.e., if the value changes to <c>true</c>).
            </summary>
        </member>
        <member name="P:MvvmCross.ViewModels.MvxNotifyTask.IsFaulted">
            <summary>
            Gets whether the task has faulted. This property raises a notification only if the task faults (i.e., if the value changes to <c>true</c>).
            </summary>
        </member>
        <member name="P:MvvmCross.ViewModels.MvxNotifyTask.Exception">
            <summary>
            Gets the wrapped faulting exception for the task. Returns <c>null</c> if the task is not faulted. This property raises a notification only if the task faults (i.e., if the value changes to non-<c>null</c>).
            </summary>
        </member>
        <member name="P:MvvmCross.ViewModels.MvxNotifyTask.InnerException">
            <summary>
            Gets the original faulting exception for the task. Returns <c>null</c> if the task is not faulted. This property raises a notification only if the task faults (i.e., if the value changes to non-<c>null</c>).
            </summary>
        </member>
        <member name="P:MvvmCross.ViewModels.MvxNotifyTask.ErrorMessage">
            <summary>
            Gets the error message for the original faulting exception for the task. Returns <c>null</c> if the task is not faulted. This property raises a notification only if the task faults (i.e., if the value changes to non-<c>null</c>).
            </summary>
        </member>
        <member name="E:MvvmCross.ViewModels.MvxNotifyTask.PropertyChanged">
            <summary>
            Event that notifies listeners of property value changes.
            </summary>
        </member>
        <member name="M:MvvmCross.ViewModels.MvxNotifyTask.Create(System.Threading.Tasks.Task,System.Action{System.Exception})">
            <summary>
            Creates a new task notifier watching the specified task.
            </summary>
            <param name="task">The task to watch.</param>
            <param name="onException">Callback to be run when an error happens</param>
        </member>
        <member name="M:MvvmCross.ViewModels.MvxNotifyTask.Create``1(System.Threading.Tasks.Task{``0},``0,System.Action{System.Exception})">
            <summary>
            Creates a new task notifier watching the specified task.
            </summary>
            <typeparam name="TResult">The type of the task result.</typeparam>
            <param name="task">The task to watch.</param>
            <param name="defaultResult">The default "result" value for the task while it is not yet complete.</param>
            <param name="onException">Callback to be run when an error happens</param>
        </member>
        <member name="M:MvvmCross.ViewModels.MvxNotifyTask.Create(System.Func{System.Threading.Tasks.Task},System.Action{System.Exception})">
            <summary>
            Executes the specified asynchronous code and creates a new task notifier watching the returned task.
            </summary>
            <param name="asyncAction">The asynchronous code to execute.</param>
            <param name="onException">Callback to be run when an error happens</param>
        </member>
        <member name="M:MvvmCross.ViewModels.MvxNotifyTask.Create``1(System.Func{System.Threading.Tasks.Task{``0}},``0,System.Action{System.Exception})">
            <summary>
            Executes the specified asynchronous code and creates a new task notifier watching the returned task.
            </summary>
            <param name="asyncAction">The asynchronous code to execute.</param>
            <param name="defaultResult">The default "result" value for the task while it is not yet complete.</param>
            <param name="onException">Callback to be run when an error happens</param>
        </member>
        <member name="T:MvvmCross.ViewModels.MvxNotifyTask`1">
            <summary>
            Watches a task and raises property-changed notifications when the task completes.
            </summary>
            <typeparam name="TResult">The type of the task result.</typeparam>
        </member>
        <member name="F:MvvmCross.ViewModels.MvxNotifyTask`1._defaultResult">
            <summary>
            The "result" of the task when it has not yet completed.
            </summary>
        </member>
        <member name="M:MvvmCross.ViewModels.MvxNotifyTask`1.#ctor(System.Threading.Tasks.Task{`0},`0,System.Action{System.Exception})">
            <summary>
            Initializes a task notifier watching the specified task.
            </summary>
            <param name="task">The task to watch.</param>
            <param name="defaultResult">The value to return from <see cref="P:MvvmCross.ViewModels.MvxNotifyTask`1.Result"/> while the task is not yet complete.</param>
            <param name="onException">Callback to be run when an error happens</param>
        </member>
        <member name="P:MvvmCross.ViewModels.MvxNotifyTask`1.Task">
            <summary>
            Gets the task being watched. This property never changes and is never <c>null</c>.
            </summary>
        </member>
        <member name="P:MvvmCross.ViewModels.MvxNotifyTask`1.TaskCompleted">
            <summary>
            Gets a task that completes successfully when <see cref="P:MvvmCross.ViewModels.MvxNotifyTask`1.Task"/> completes (successfully, faulted, or canceled). This property never changes and is never <c>null</c>.
            </summary>
        </member>
        <member name="P:MvvmCross.ViewModels.MvxNotifyTask`1.Result">
            <summary>
            Gets the result of the task. Returns the "default result" value specified in the constructor if the task has not yet completed successfully. This property raises a notification when the task completes successfully.
            </summary>
        </member>
        <member name="P:MvvmCross.ViewModels.MvxNotifyTask`1.Status">
            <summary>
            Gets the current task status. This property raises a notification when the task completes.
            </summary>
        </member>
        <member name="P:MvvmCross.ViewModels.MvxNotifyTask`1.IsCompleted">
            <summary>
            Gets whether the task has completed. This property raises a notification when the value changes to <c>true</c>.
            </summary>
        </member>
        <member name="P:MvvmCross.ViewModels.MvxNotifyTask`1.IsNotCompleted">
            <summary>
            Gets whether the task is busy (not completed). This property raises a notification when the value changes to <c>false</c>.
            </summary>
        </member>
        <member name="P:MvvmCross.ViewModels.MvxNotifyTask`1.IsSuccessfullyCompleted">
            <summary>
            Gets whether the task has completed successfully. This property raises a notification when the value changes to <c>true</c>.
            </summary>
        </member>
        <member name="P:MvvmCross.ViewModels.MvxNotifyTask`1.IsCanceled">
            <summary>
            Gets whether the task has been canceled. This property raises a notification only if the task is canceled (i.e., if the value changes to <c>true</c>).
            </summary>
        </member>
        <member name="P:MvvmCross.ViewModels.MvxNotifyTask`1.IsFaulted">
            <summary>
            Gets whether the task has faulted. This property raises a notification only if the task faults (i.e., if the value changes to <c>true</c>).
            </summary>
        </member>
        <member name="P:MvvmCross.ViewModels.MvxNotifyTask`1.Exception">
            <summary>
            Gets the wrapped faulting exception for the task. Returns <c>null</c> if the task is not faulted. This property raises a notification only if the task faults (i.e., if the value changes to non-<c>null</c>).
            </summary>
        </member>
        <member name="P:MvvmCross.ViewModels.MvxNotifyTask`1.InnerException">
            <summary>
            Gets the original faulting exception for the task. Returns <c>null</c> if the task is not faulted. This property raises a notification only if the task faults (i.e., if the value changes to non-<c>null</c>).
            </summary>
        </member>
        <member name="P:MvvmCross.ViewModels.MvxNotifyTask`1.ErrorMessage">
            <summary>
            Gets the error message for the original faulting exception for the task. Returns <c>null</c> if the task is not faulted. This property raises a notification only if the task faults (i.e., if the value changes to non-<c>null</c>).
            </summary>
        </member>
        <member name="E:MvvmCross.ViewModels.MvxNotifyTask`1.PropertyChanged">
            <summary>
            Event that notifies listeners of property value changes.
            </summary>
        </member>
        <member name="M:MvvmCross.ViewModels.MvxObservableCollection`1.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:MvvmCross.ViewModels.MvxObservableCollection`1"/> class.
            </summary>
        </member>
        <member name="M:MvvmCross.ViewModels.MvxObservableCollection`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:MvvmCross.ViewModels.MvxObservableCollection`1"/> class.
            </summary>
            <param name="items">The collection from which the items are copied.</param>
        </member>
        <member name="M:MvvmCross.ViewModels.MvxObservableCollection`1.OnCollectionChanged(System.Collections.Specialized.NotifyCollectionChangedEventArgs)">
            <summary>
            Raises the <see cref="E:System.Collections.ObjectModel.ObservableCollection`1.CollectionChanged"/> event with the provided event data.
            </summary>
            <param name="e">The event data to report in the event.</param>
        </member>
        <member name="M:MvvmCross.ViewModels.MvxObservableCollection`1.AddRange(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Adds the specified items collection to the current <see cref="T:MvvmCross.ViewModels.MvxObservableCollection`1"/> instance.
            </summary>
            <param name="items">The collection from which the items are copied.</param>
            <exception cref="T:System.ArgumentNullException">The items list is null.</exception>
        </member>
        <member name="M:MvvmCross.ViewModels.MvxObservableCollection`1.ReplaceWith(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Replaces the current <see cref="T:MvvmCross.ViewModels.MvxObservableCollection`1"/> instance items with the ones specified in the items collection, raising a single <see cref="F:System.Collections.Specialized.NotifyCollectionChangedAction.Reset"/> event.
            </summary>
            <param name="items">The collection from which the items are copied.</param>
            <exception cref="T:System.ArgumentNullException">The items list is null.</exception>
        </member>
        <member name="M:MvvmCross.ViewModels.MvxObservableCollection`1.SwitchTo(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Switches the current <see cref="T:MvvmCross.ViewModels.MvxObservableCollection`1"/> instance items with the ones specified in the items collection, raising the minimum required change events.
            </summary>
            <param name="items">The collection from which the items are copied.</param>
            <exception cref="T:System.ArgumentNullException">The items list is null.</exception>
        </member>
        <member name="M:MvvmCross.ViewModels.MvxObservableCollection`1.RemoveItems(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Removes the current <see cref="T:MvvmCross.ViewModels.MvxObservableCollection`1"/> instance items of the ones specified in the items collection, raising the minimum required change events.
            </summary>
            <param name="items">The collection which items will be removed.</param>
            <exception cref="T:System.ArgumentNullException">The items list is null.</exception>
        </member>
        <member name="M:MvvmCross.ViewModels.MvxObservableCollection`1.RemoveRange(System.Int32,System.Int32)">
            <summary>
            Removes the current <see cref="T:MvvmCross.ViewModels.MvxObservableCollection`1"/> instance items of the ones specified in the range, raising the minimum required change events.
            </summary>
            <param name="start">The start index.</param>
            <param name="count">The count of items to remove.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">Start index or count incorrect</exception>
        </member>
        <member name="T:MvvmCross.ViewModels.PropertyChangedEventArgsCache">
            <summary>
            Provides a cache for <see cref="T:System.ComponentModel.PropertyChangedEventArgs"/> instances.
            </summary>
        </member>
        <member name="F:MvvmCross.ViewModels.PropertyChangedEventArgsCache._cache">
            <summary>
            The underlying dictionary. This instance is its own mutex.
            </summary>
        </member>
        <member name="M:MvvmCross.ViewModels.PropertyChangedEventArgsCache.#ctor">
            <summary>
            Private constructor to prevent other instances.
            </summary>
        </member>
        <member name="P:MvvmCross.ViewModels.PropertyChangedEventArgsCache.Instance">
            <summary>
            The global instance of the cache.
            </summary>
        </member>
        <member name="M:MvvmCross.ViewModels.PropertyChangedEventArgsCache.Get(System.String)">
            <summary>
            Retrieves a <see cref="T:System.ComponentModel.PropertyChangedEventArgs"/> instance for the specified property, creating it and adding it to the cache if necessary.
            </summary>
            <param name="propertyName">The name of the property that changed.</param>
        </member>
    </members>
</doc>
